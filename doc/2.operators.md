# 运算符

1. 下面的结果是什么？为什么？

```js
1 + 1
true + true
1 + true
'a' + 'bc'
1 + 'a'
false + 'a'
'3' + 4 + 5
3 + 4 + '5'
1 - '2'
1 * '2'
1 / '2'
```

<details>
<summary>答案</summary>

```js
1 + 1 // 2
true + true // 2
1 + true // 2
'a' + 'bc' // "abc"
1 + 'a' // "1a"
false + 'a' // "falsea"
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，`运算子的不同，导致了不同的语法行为`，这种现象称为`“重载”（overload）`。布尔值都会自动转成数值，然后再相加。如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。
</details>

2. 下面的结果是什么？为什么？

```js
var obj = { p: 1 };
obj + 2
```

<details>
<summary>答案</summary>

```js
var obj = { p: 1 };
obj + 2 // "[object Object]2"
```

如果运算子是对象，必须先转成原始类型的值，然后再相加。对象转成原始类型的值，规则如下：<br>
* 自动调用对象的 `valueOf` 方法，对象的 `valueOf` 方法总是返回对象自身
* 再自动调用对象的 `toString` 方法，将其转为字符串

```js
var obj = { p: 1 };
obj.valueOf().toString() // "[object Object]"
```

这里有一个特例，如果运算子是一个 `Date` 对象的实例，那么会优先执行 `toString` 方法。

```js
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };

obj + 2 // "hello2"
```
</details>

3. 下面的结果是什么？为什么？

```js
-1 % 2
1 % -2
```

<details>
<summary>答案</summary>

```js
-1 % 2 // -1
1 % -2 // 1
```

取余运算结果的正负号由第一个运算子的正负号决定。如果想得到正确的余数，请使用绝对值函数 `Math.abs()` 。
</details>

4. 下面的结果是什么？为什么？

```js
var x = 1;
var y = 1;

x++
++y
```

<details>
<summary>答案</summary>

```js
var x = 1;
var y = 1;

x++ //1
++y //2
```

自增自减运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。<br>
自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。
</details>

