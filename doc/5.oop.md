# 面向对象

1. `new` 命令的原理？

<details>
<summary>答案</summary>

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的prototype属性。
3. 将这个空对象赋值给函数内部的this关键字。
4. 开始执行构造函数内部的代码。

下面是 `new` 命令简化的内部流程：

```js
function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {
  // 将 arguments 对象转为数组
  var args = [].slice.call(arguments);
  // 取出构造函数
  var constructor = args.shift();
  // 创建一个空对象，继承构造函数的 prototype 属性
  var context = Object.create(constructor.prototype);
  // 执行构造函数
  var result = constructor.apply(context, args);
  // 如果返回结果是对象，就直接返回，否则返回 context 对象
  return (typeof result === 'object' && result != null) ? result : context;
}

// 实例
var actor = _new(Person, '张三', 28);
```

</details>
<br><br>

2. 如果在构造函数中判断当前是否是 `new` 调用？

<details>
<summary>答案</summary>

* 使用 `instanceof `

```js
function Something () {
    if (!(this instanceof Something)) {
        return new Something();
    }
    this.data = 100;
}
```

* 使用 `new.target`

```js
function f () {
  if (!new.target) {
    throw new Error('请使用 new 命令调用！');
  }
  // ...
}

f() // Uncaught Error: 请使用 new 命令调用！
```
函数内部可以使用 `new.target` 属性。如果当前函数是 `new` 命令调用，`new.target` 指向当前函数，否则为 `undefined`。

</details>
<br><br>

3. 怎样将 `slice`、`push`、`pop`、`bind`等方法从实例调用变成方法直接调用？

<details>
<summary>答案</summary>

使用 `bind` 方法：

```js
var slice = Function.prototype.call.bind(Array.prototype.slice);
slice([1, 2, 3], 0, 1) // [1]

var push = Function.prototype.call.bind(Array.prototype.push);
var pop = Function.prototype.call.bind(Array.prototype.pop);

var a = [1 ,2 ,3];
push(a, 4)
a // [1, 2, 3, 4]

pop(a)
a // [1, 2, 3]



function f() {
  console.log(this.v);
}

var o = { v: 123 };
var bind = Function.prototype.call.bind(Function.prototype.bind);
bind(f, o)() // 123
```
</details>
<br><br>

4. 如何判断 `this` 的指向？

<details>
<summary>答案</summary>

* 函数是否在new 中调用（new 绑定）？如果是的话this 绑定的是新创建的对象。

```js
var bar = new foo()
```

* 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。

```js
var bar = foo.call(obj2)
```

* 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。

```js
var bar = obj1.foo()
```

* 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。

```js
var bar = foo()
```

* 一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定。

```js
function foo() {
　　console.log( this.a );
}
var obj = {
　　a: 2,
　　foo: foo
};
var bar = obj.foo; // 函数别名！
var a = "oops, global"; // a 是全局对象的属性
bar(); // "oops, global"
```

还有将函数作为参数传递的情况：

```js
function foo() {
　　console.log( this.a );
}
function doFoo(fn) {
　　// fn 其实引用的是foo
　　fn(); // <-- 调用位置！
}
var obj = {
　　a: 2,
　　foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
doFoo( obj.foo ); // "oops, global"
```

还有 setTimeout 也一样：

```js
function foo() {
　　console.log( this.a );
}
var obj = {
　　a: 2,
　　foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
setTimeout( obj.foo, 100 ); // "oops, global"
```

还有数组的那些遍历处理的方法，也是将函数作为参数传递进去：

```js
var o = {
  v: 'hello',
  p: [ 'a1', 'a2' ],
  f: function f() {
    this.p.forEach(function (item) {
      console.log(this.v + ' ' + item);
    });
  }
}

o.f()
// undefined a1
// undefined a2
```

对象的方法中立即执行的函数也会使用默认绑定：

```js
var o = {
  f1: function () {
    console.log(this);
    var f2 = function () {
      console.log(this);
    }();
  }
}

o.f1()
// Object
// Window
```

回调函数也会丢失绑定，使用默认绑定：

```js
var o = new Object();
o.f = function () {
  console.log(this === o);
}

// jQuery 的写法
$('#button').on('click', o.f);
```

赋值表达式，条件表达式，逗号表达式的返回值都会使函数中的 this 丢失之前的隐式绑定，而去使用默认绑定，将 this 绑定到 window 上：

```js
// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window
```


</details>
<br><br>

5. 什么是原型链？

<details>
<summary>答案</summary>

* 每个构造函数都有一个原型对象 `prototype`，例如：`Object.prototype`
* 原型对象都包含一个指向构造函数本身的指针 `constructor`，例如：`Object === Object.prototype.constructor`
* 实例都包含一个指向原型对象的内部指针 `__proto__`，例如：`obj.__proto__ === Object.prototype`
* 当一个构造函数的原型对象 `prototype` 是另外一个原型对象的实例的时候，内部指针 `__proto__` 会将这些原型对象串联起来，这就是 `原型链`。

```js
String.prototype.__proto__ === Object.prototype
// String 类型的原型对象的内部指针 __proto__ 指向了 Object 类型的原型对象
```
如下图所示：

```js
                 .prototype             ┌───────────────────┐      .__proto__
            ┌───────────────────────────►  Array.prototype  ├─────────────────────┐    .__proto__    ┌────────┐
            │                           └──┬────────────────┘                     │ ┌───────────────►│ null   │
            │        .constructor          │                                      │ │                └────────┘
       ┌────┼──────────────────────────────┘                                      │ │
       │    │                                                                     │ │
       │    │                                                                     │ │
       │    │                                                                     │ │
┌──────▼──┐ │                                                                   ┌─▼─┴──────────────────┐
│  Array  ├─┘                                                             ┌─────┤  Object.prototype    ◄───────────┐
└─────────┘                                                               │     └──────────────────────┘           │
                                                                          │                                        │
                                                                          │                                        │
                                                                          │                                        │
                                                                          │ .constructor                           │
                                                                          └───────────────────┐                    │
                                                                                              │                    │
                                                                                              │                    │
                                                                                              │                    │
                                                                                              │                    │
                                                                                 ┌────────────▼──┐ .prototype      │
                                                                                 │  Object       ├─────────────────┘
                                                                                 └───────────────┘
```

但是所有构造函数都是 Function 类型的对象，拥有 Function 类型的属性和方法，构造函数和 Function.prototype 是什么关系呢？<br>

其实，所有构造函数都有一个内部指针 `__proto__` 指向了 `Function.prototype`，如下图所示：

```js
                 .prototype             ┌───────────────────┐      .__proto__
            ┌───────────────────────────►  Array.prototype  ├─────────────────────┐    .__proto__    ┌────────┐
            │                           └──┬────────────────┘                     │ ┌───────────────►│ null   │
            │        .constructor          │                                      │ │                └────────┘
       ┌────┼──────────────────────────────┘                                      │ │
       │    │                                                                     │ │
       │    │                                                                     │ │
       │    │                                                                     │ │
┌──────▼──┐ │                                                                   ┌─▼─┴──────────────────┐
│  Array  ├─┘                                                             ┌─────┤  Object.prototype    ◄───────────┐
└───┬─────┘                                                               │     └────▲─────────────────┘           │
    │                                                                     │          │                             │
    │          .__proto__                                  .__proto__     │          │                             │
    └───────────────────────────┐             ┌───────────────────────────┼──────────┘                             │
                                │             │                           │                                        │
                                │             │                           │ .constructor                           │
                                │             │                           └───────────────────┐                    │
                                │             │                                               │                    │
                                │             │                                               │                    │
                                │             │                                               │                    │
                                │             │                                               │                    │
┌──────────┐  .prototype    ┌───▼─────────────┴──┐         .__proto__            ┌────────────▼──┐ .prototype      │
│ Function ├────────────────► Function.prototype ◄───────────────────────────────┤  Object       ├─────────────────┘
└─┬───▲────┘                └──────────────┬──▲──┘                               └───────────────┘
  │   │        .constructor                │  │
  │   └────────────────────────────────────┘  │
  │                                           │
  │              .__proto__                   │
  └───────────────────────────────────────────┘
```

这样就解决了构造函数拥有 `Function.prototype` 上的属性和方法的问题。[查看](https://asciiflow.com/#/share/eJztV0tqwzAQvYqZdQi0UGi866bbXkBgXKNFiisFVYaYEOiiRyjOPbIMPU1OUsdOan0d2ZbTQCtmYQXNmzfjp5l4BSR%2BxRCSLE0nkMY5ZhDCCsESQTi7u5kgyMun29l9%2BcTxkpcbBIG6pgtGOeX5Aks%2F7z%2B%2FhtgRO4oq9ChCiHhEN1uxC4IHxuJcTMkLtJzL%2BQT0bLWye660jtkdt9gd3A5yqhHsWUwTSt44yxJOmWuaOrtuhWjYjCKejgW25SSx7FSUP4NvEZ9QcD8xdeB%2BVlM%2BthZBfT7IqUp7en7BCZdb8n7z4U7Th5TbSBvJF9vBN6uRnkJTHCEssC25OSt09Y05t4aAg707mL32AyXZ2xxLcOZU67799C%2BENw%2BrS4X3%2FbbGoOmC8B%2F%2BWsK7KUeZIVK7HqRFY6t1Vro45tUvj5%2F0gseMJHxOSa8LVH4GnPyFCPW%2F21HtNL47lkQz8zvWhqxBHb3KtbUiDg9Q3ZYaWcBv68jVMc3zwqYycF1WL%2FOl0b2uwRCsYf0NiW0upw%3D%3D)) <br>

读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。
</details>
<br><br>

6. 下面的结果是什么？为什么？

```js
var obj = Object.create(null);
typeof obj
obj instanceof Object
```

<details>
<summary>答案</summary>

```js
var obj = Object.create(null);
typeof obj // "object"
obj instanceof Object // false
```

`Object.create(null)`返回一个新对象obj，它的原型是 null。右边的构造函数 Object 的 prototype 属性，不在左边的原型链上，因此 instanceof 就认为 obj 不是 Object 的实例。这是唯一的 `instanceof` 运算符判断会失真的情况（一个对象的原型是null）。
</details>
<br><br>

7. 简单说一下继承如何实现？

<details>
<summary>答案</summary>

* 在子类的构造函数中，调用父类的构造函数

```js
function Sub(value) {
  Super.call(this);
  this.prop = value;
}
```

* 子类的原型指向父类的原型，这样子类就可以继承父类原型

```js
Sub.prototype = Object.create(Super.prototype);
Sub.prototype.constructor = Sub;
Sub.prototype.method = '...';
```

* 子类的原型等于一个父类实例

```js
Sub.prototype = new Super();
```
这样子类会有父类实例的方法，所以不建议用这种方式。

</details>
<br><br>